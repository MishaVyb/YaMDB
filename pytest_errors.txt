============================= test session starts ==============================
platform darwin -- Python 3.8.9, pytest-6.2.4, py-1.11.0, pluggy-0.13.1 -- /Users/alexey/Dev/api_yamdb/venv/bin/python3
django: settings: api_yamdb.settings (from ini)
rootdir: /Users/alexey/Dev/api_yamdb, configfile: pytest.ini, testpaths: tests/
plugins: pythonpath-0.7.3, django-4.4.0
collecting ... collected 53 items

tests/test_00_user_registration.py::Test00UserRegistration::test_00_nodata_signup FAILED [  1%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_invalid_data_signup FAILED [  3%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_valid_data_user_signup FAILED [  5%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_valid_data_admin_create_user FAILED [  7%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_obtain_jwt_token_invalid_data FAILED [  9%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_registration_me_username_restricted FAILED [ 11%]
tests/test_00_user_registration.py::Test00UserRegistration::test_00_registration_same_email_restricted FAILED [ 13%]
tests/test_01_users.py::Test01UserAPI::test_01_users_not_authenticated FAILED [ 15%]
tests/test_01_users.py::Test01UserAPI::test_02_users_username_not_authenticated 

=================================== FAILURES ===================================
_________________ Test00UserRegistration.test_00_nodata_signup _________________

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x10c7838b0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/signup/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c754e50>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c754e50>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c7eec90, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c6db9d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c6db9d0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c8fda80, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10c7b1a90>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c79b640>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c754af0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c754af0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c7eed40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c914160>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c914160>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c912240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10c7b1610>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c6cf600>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c754c40>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c754c40>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c80c3a0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c91a340>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c91a340>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c91e450, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10c7b1490>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c74b6c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c754f40>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c754f40>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c80c190, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c9234f0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c9234f0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c92c450, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10c7b1df0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c68bb40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c78c100>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c78c100>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c80c450, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c9346a0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c9346a0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9385b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10c7b1910>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c8186c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c78c700>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c78c700>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c80c500, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c93f850>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c93f850>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9465b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10c7b15b0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c6ded00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c78c040>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c78c040>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c80c5b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c94da00>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c94da00>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c955710, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10c783970>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c947400>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c78c130>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c78c130>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c80c870, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c95abb0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c95abb0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c964710, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x10c56b5b0>
client = <django.test.client.Client object at 0x10c783bb0>

    @pytest.mark.django_db(transaction=True)
    def test_00_nodata_signup(self, client):
        request_type = 'POST'
>       response = client.post(self.url_signup)

tests/test_00_user_registration.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/django/test/client.py:543: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv/lib/python3.8/site-packages/django/test/client.py:356: in post
    return self.generic('POST', path, post_data, content_type,
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
---------------------------- Captured stdout setup -----------------------------
Operations to perform:
  Synchronize unmigrated apps: messages, rest_framework_simplejwt, staticfiles
  Apply all migrations: admin, auth, contenttypes, reviews, sessions, users
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0001_initial... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying users.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying reviews.0001_initial... OK
  Applying reviews.0002_auto_20220825_1157... OK
  Applying reviews.0003_auto_20220825_1222... OK
  Applying reviews.0004_auto_20220825_1301... OK
  Applying sessions.0001_initial... OK
---------------------------- Captured stderr setup -----------------------------
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
______________ Test00UserRegistration.test_00_invalid_data_signup ______________

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x10cbeaf10>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/signup/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd5130>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd5130>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c857030, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb8ea30>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb8ea30>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9ae9d0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10cbd5fd0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cc7cc00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd5220>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd5220>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca3dc90, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb5b760>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb5b760>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9bbea0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10cbd5f40>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ca1df00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd5700>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd5700>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca3df50, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb5ba60>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb5ba60>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc97190, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10cbd52e0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ca1fa00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd02b0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd02b0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca0bf50, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb47220>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb47220>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc9a2f0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10cbd50a0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ca31440>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd0370>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd0370>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca3d660, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c768a00>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c768a00>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc755b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10cbd51c0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ca27fc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd02e0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd02e0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca3d240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c6f29d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c6f29d0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cba5710, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10cbd5280>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cb4a240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd0310>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd0310>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca0c920, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c6fafd0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c6fafd0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb999d0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10cbd51f0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c75b840>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd0460>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd0460>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca06be0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c88d1f0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c88d1f0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb84b30, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x10cc785e0>
client = <django.test.client.Client object at 0x10cbea460>

    @pytest.mark.django_db(transaction=True)
    def test_00_invalid_data_signup(self, client):
        invalid_email = 'invalid_email'
        invalid_username = 'invalid_username@yamdb.fake'
    
        invalid_data = {
            'email': invalid_email,
            'username': invalid_username
        }
        request_type = 'POST'
>       response = client.post(self.url_signup, data=invalid_data)

tests/test_00_user_registration.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/django/test/client.py:543: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv/lib/python3.8/site-packages/django/test/client.py:356: in post
    return self.generic('POST', path, post_data, content_type,
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
____________ Test00UserRegistration.test_00_valid_data_user_signup _____________

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x10cd0b7c0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/signup/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cd05d00>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cd05d00>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ceb1450, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cc36400>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cc36400>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cdc0920, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10cd05ee0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cd10cc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cd05e80>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cd05e80>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cea3b30, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cc20220>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cc20220>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cda8ea0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10cd05730>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cdc1700>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cd05df0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cd05df0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca0bbe0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cc204c0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cc204c0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cbc0030, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10cd052b0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cbbbdc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cd05e20>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cd05e20>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ceaf660, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cc180a0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cc180a0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cbcf2f0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10cd05280>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cc9b240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cd05eb0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cd05eb0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ceb1660, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbb4e50>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbb4e50>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cbed450, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10cd05340>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cc31cc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ccff8b0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ccff8b0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ceb13a0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbb7040>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbb7040>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cbe0710, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10cd053a0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cbb83c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ccff6d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ccff6d0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ceb1be0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cc85910>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cc85910>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cd19870, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10cd053d0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cdbc0c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ccfff10>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ccfff10>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ceb15b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb8ec40>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb8ec40>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cd12b30, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x10cd2c670>
client = <django.test.client.Client object at 0x10cd0bc10>

    @pytest.mark.django_db(transaction=True)
    def test_00_valid_data_user_signup(self, client):
    
        valid_email = 'valid@yamdb.fake'
        valid_username = 'valid_username'
        outbox_before_count = len(mail.outbox)
    
        valid_data = {
            'email': valid_email,
            'username': valid_username
        }
        request_type = 'POST'
>       response = client.post(self.url_signup, data=valid_data)

tests/test_00_user_registration.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/django/test/client.py:543: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv/lib/python3.8/site-packages/django/test/client.py:356: in post
    return self.generic('POST', path, post_data, content_type,
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
_________ Test00UserRegistration.test_00_valid_data_admin_create_user __________

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <rest_framework.test.ForceAuthClientHandler object at 0x10c9098e0>
request = <WSGIRequest: POST '/api/v1/users/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/users/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce37a90>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce37a90>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ce62f50, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cc85ca0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cc85ca0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb6cb30, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10c909d30>
request = <WSGIRequest: POST '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cb57ac0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce37c40>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce37c40>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ce62d40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c6ec3a0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c6ec3a0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb53d40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10c909e20>
request = <WSGIRequest: POST '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cb6f1c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce376a0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce376a0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb65500, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c768070>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c768070>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb36ea0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10c909d90>
request = <WSGIRequest: POST '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cb4cf00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce37ca0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce37ca0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb6c710, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb5b400>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb5b400>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc49f50, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10c909070>
request = <WSGIRequest: POST '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cc37b80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce37dc0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce37dc0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ce62be0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbd5790>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbd5790>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc58240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10c909700>
request = <WSGIRequest: POST '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cc43880>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce37d90>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce37d90>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb4fbe0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cce37c0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cce37c0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc643a0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10ce372b0>
request = <WSGIRequest: POST '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cb44800>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce37610>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce37610>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb4fd40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10c9ca8e0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10c9ca8e0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc5f660, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10ce371f0>
request = <WSGIRequest: POST '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cc67ec0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cc531f0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cc531f0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb35c90, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cf32a30>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cf32a30>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cebe7c0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x10ccc0fd0>
admin_client = <rest_framework.test.APIClient object at 0x10cce08b0>

    @pytest.mark.django_db(transaction=True)
    def test_00_valid_data_admin_create_user(self, admin_client):
    
        valid_email = 'valid@yamdb.fake'
        valid_username = 'valid_username'
        outbox_before_count = len(mail.outbox)
    
        valid_data = {
            'email': valid_email,
            'username': valid_username
        }
        request_type = 'POST'
>       response = admin_client.post(self.url_admin_create_user, data=valid_data)

tests/test_00_user_registration.py:134: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/rest_framework/test.py:295: in post
    response = super().post(
venv/lib/python3.8/site-packages/rest_framework/test.py:209: in post
    return self.generic('POST', path, data, content_type, **extra)
venv/lib/python3.8/site-packages/rest_framework/test.py:233: in generic
    return super().generic(
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/rest_framework/test.py:285: in request
    return super().request(**kwargs)
venv/lib/python3.8/site-packages/rest_framework/test.py:237: in request
    request = super().request(**kwargs)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/rest_framework/test.py:257: in get_response
    return super().get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
_________ Test00UserRegistration.test_00_obtain_jwt_token_invalid_data _________

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x10d0fcc40>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/token/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d12e580>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d12e580>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9b4240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cfe6790>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cfe6790>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cef1b30, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10d1197c0>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d100100>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d38bb20>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d38bb20>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cee40e0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cfe69d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cfe69d0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d43c0e0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10d119cd0>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ced1840>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d38ba00>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d38ba00>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc75ea0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cfd26d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cfd26d0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d446240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10d119d90>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cb3b980>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d38b940>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d38b940>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d3cc0e0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cfe65e0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cfe65e0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d449d40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10d119970>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c6cf0c0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d38bf10>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d38bf10>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cd92240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d01eb20>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d01eb20>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d129d40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10d119a60>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cf87080>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d38bdc0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d38bdc0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9b4030, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ccfd370>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ccfd370>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d103030, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10d1199d0>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cb51ac0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d38b130>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d38b130>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cee8030, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce27c70>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce27c70>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cf8e190, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10d12e130>
request = <WSGIRequest: POST '/api/v1/auth/token/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/token/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d0fe680>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d38bfa0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d38bfa0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cee3190, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce275e0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce275e0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cf9e450, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x10d10cf70>
client = <django.test.client.Client object at 0x10d0fc700>

    @pytest.mark.django_db(transaction=True)
    def test_00_obtain_jwt_token_invalid_data(self, client):
    
        request_type = 'POST'
>       response = client.post(self.url_token)

tests/test_00_user_registration.py:171: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/django/test/client.py:543: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv/lib/python3.8/site-packages/django/test/client.py:356: in post
    return self.generic('POST', path, post_data, content_type,
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
______ Test00UserRegistration.test_00_registration_me_username_restricted ______

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x10d0c4220>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/signup/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0c2fd0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0c2fd0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cee3df0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0a28b0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0a28b0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d450500, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10d0c25e0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d0cc880>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0c2f40>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0c2f40>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cee3c90, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0a2040>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0a2040>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cfcea80, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10d0c2280>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d38a800>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0c2d90>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0c2d90>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d506be0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cf22f10>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cf22f10>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cfd8be0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10d0c2730>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d388d00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0c2e80>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0c2e80>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d506660, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cf22190>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cf22190>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cfdcea0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10d0c2670>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cfc8ac0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0c2f10>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0c2f10>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d508c90, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0a2610>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0a2610>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cfc3870, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10d0c2220>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cfc8f40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0c2ee0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0c2ee0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d4e8d40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cd16be0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cd16be0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c91e3a0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10d0c2a30>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d36dac0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0bf040>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0bf040>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d508500, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cfd2c70>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cfd2c70>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9b4450, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10d0c2880>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d0efcc0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0bf190>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0bf190>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d4519d0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cfbe160>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cfbe160>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cf76920, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x10d0f0070>
client = <django.test.client.Client object at 0x10d0c4880>

    @pytest.mark.django_db(transaction=True)
    def test_00_registration_me_username_restricted(self, client):
        valid_email = 'valid@yamdb.fake'
        invalid_username = 'me'
        request_type = 'POST'
    
        valid_data = {
            'email': valid_email,
            'username': invalid_username
        }
>       response = client.post(self.url_signup, data=valid_data)

tests/test_00_user_registration.py:237: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/django/test/client.py:543: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv/lib/python3.8/site-packages/django/test/client.py:356: in post
    return self.generic('POST', path, post_data, content_type,
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
______ Test00UserRegistration.test_00_registration_same_email_restricted _______

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x10d08ed90>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
path = '/api/v1/auth/signup/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d4f0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d4f0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb43c90, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb328b0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb328b0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ced0d40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10d02e2e0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d080ec0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d610>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d610>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d5035b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb32a60>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb32a60>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cfc3190, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10d07d670>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ccfbe80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d700>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d700>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d5037c0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb6c8e0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb6c8e0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cdc00e0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10d07d190>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ccda880>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d880>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d880>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d503920, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbb44c0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbb44c0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ca06870, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10d07dee0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cdb7380>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d9d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d9d0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb43920, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbb4a00>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbb4a00>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cd99240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10d07ddf0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10ccfcc00>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d910>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d910>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d40f3a0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbb7a90>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbb7a90>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cdaf240, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10d07d490>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cfccec0>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d7c0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d7c0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d508030, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cbb4b50>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cbb4b50>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cbe05b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10d07dcd0>
request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: POST '/api/v1/auth/signup/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d11e940>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d07d760>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d07d760>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d40fd40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10cb5bf40>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10cb5bf40>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cd192f0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_00_user_registration.Test00UserRegistration object at 0x10d07e3a0>
client = <django.test.client.Client object at 0x10d07e9a0>

    @pytest.mark.django_db(transaction=True)
    def test_00_registration_same_email_restricted(self, client):
        valid_email_1 = 'test_duplicate_1@yamdb.fake'
        valid_email_2 = 'test_duplicate_2@yamdb.fake'
        valid_username_1 = 'valid_username_1'
        valid_username_2 = 'valid_username_2'
        request_type = 'POST'
    
        valid_data = {
            'email': valid_email_1,
            'username': valid_username_1
        }
>       response = client.post(self.url_signup, data=valid_data)

tests/test_00_user_registration.py:256: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/django/test/client.py:543: in post
    response = super().post(path, data=data, content_type=content_type, secure=secure, **extra)
venv/lib/python3.8/site-packages/django/test/client.py:356: in post
    return self.generic('POST', path, post_data, content_type,
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
________________ Test01UserAPI.test_01_users_not_authenticated _________________

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.test.client.ClientHandler object at 0x10d4a7430>
request = <WSGIRequest: GET '/api/v1/users/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
    
        if hasattr(request, 'urlconf'):
            urlconf = request.urlconf
            set_urlconf(urlconf)
            resolver = get_resolver(urlconf)
        else:
            resolver = get_resolver()
    
>       resolver_match = resolver.resolve(request.path_info)

venv/lib/python3.8/site-packages/django/core/handlers/base.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, path = '/api/v1/users/'

    def resolve(self, path):
        path = str(path)  # path may be a reverse_lazy object
        tried = []
        match = self.pattern.match(path)
        if match:
            new_path, args, kwargs = match
>           for pattern in self.url_patterns:

venv/lib/python3.8/site-packages/django/urls/resolvers.py:540: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdc0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def url_patterns(self):
        # urlconf_module might be a valid set of patterns, so we default to it
>       patterns = getattr(self.urlconf_module, "urlpatterns", self.urlconf_module)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d4a4ee0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d4a4ee0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cee72f0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d39c3a0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d39c3a0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d546be0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.clickjacking.XFrameOptionsMiddleware object at 0x10d4a41f0>
request = <WSGIRequest: GET '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10d4ada80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d4a4e50>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d4a4e50>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cd92df0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d3703a0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d3703a0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb40190, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.messages.middleware.MessageMiddleware object at 0x10d4a47c0>
request = <WSGIRequest: GET '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10c9cb240>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d4a43d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d4a43d0>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10c9b40e0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d3705b0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d3705b0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d1202f0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.auth.middleware.AuthenticationMiddleware object at 0x10d4a4730>
request = <WSGIRequest: GET '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cbe3e40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d4a4460>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d4a4460>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb48df0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d128bb0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d128bb0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d1085b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.csrf.CsrfViewMiddleware object at 0x10d4a4700>
request = <WSGIRequest: GET '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cccdc80>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d4a4280>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d4a4280>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cb485b0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d0234c0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d0234c0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d118710, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.common.CommonMiddleware object at 0x10d4a4550>
request = <WSGIRequest: GET '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cca8400>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d4a4400>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d4a4400>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10cc58a80, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce276a0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce276a0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d4429d0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.contrib.sessions.middleware.SessionMiddleware object at 0x10d4a4580>
request = <WSGIRequest: GET '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cc16840>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d4a4430>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d4a4430>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ccfed40, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d01e3d0>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d01e3d0>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d43bb30, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.middleware.security.SecurityMiddleware object at 0x10d4a4af0>
request = <WSGIRequest: GET '/api/v1/users/'>

    def __call__(self, request):
        response = None
        if hasattr(self, 'process_request'):
            response = self.process_request(request)
>       response = response or self.get_response(request)

venv/lib/python3.8/site-packages/django/utils/deprecation.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>

    @wraps(get_response)
    def inner(request):
        try:
            response = get_response(request)
        except Exception as exc:
>           response = response_for_exception(request, exc)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
exc = NameError("name 'serializer_field' is not defined")

    def response_for_exception(request, exc):
        if isinstance(exc, Http404):
            if settings.DEBUG:
                response = debug.technical_404_response(request, exc)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 404, exc)
    
        elif isinstance(exc, PermissionDenied):
            response = get_exception_response(request, get_resolver(get_urlconf()), 403, exc)
            log_response(
                'Forbidden (Permission denied): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, MultiPartParserError):
            response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
            log_response(
                'Bad request (Unable to parse request body): %s', request.path,
                response=response,
                request=request,
                exc_info=sys.exc_info(),
            )
    
        elif isinstance(exc, SuspiciousOperation):
            if isinstance(exc, (RequestDataTooBig, TooManyFieldsSent)):
                # POST data can't be accessed again, otherwise the original
                # exception would be raised.
                request._mark_post_parse_error()
    
            # The request logger receives events for any problematic request
            # The security logger receives events for all SuspiciousOperations
            security_logger = logging.getLogger('django.security.%s' % exc.__class__.__name__)
            security_logger.error(
                str(exc),
                extra={'status_code': 400, 'request': request},
            )
            if settings.DEBUG:
                response = debug.technical_500_response(request, *sys.exc_info(), status_code=400)
            else:
                response = get_exception_response(request, get_resolver(get_urlconf()), 400, exc)
    
        elif isinstance(exc, SystemExit):
            # Allow sys.exit() to actually exit. See tickets #1023 and #4701
            raise
    
        else:
            signals.got_request_exception.send(sender=None, request=request)
>           response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

request = <WSGIRequest: GET '/api/v1/users/'>
resolver = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
exc_info = (<class 'NameError'>, NameError("name 'serializer_field' is not defined"), <traceback object at 0x10cbdcc40>)

    def handle_uncaught_exception(request, resolver, exc_info):
        """
        Processing for any otherwise uncaught exceptions (those that will
        generate HTTP 500 responses).
        """
        if settings.DEBUG_PROPAGATE_EXCEPTIONS:
            raise
    
        if settings.DEBUG:
            return debug.technical_500_response(request, *exc_info)
    
        # Return an HttpResponse that displays a friendly error message.
>       callback, param_dict = resolver.resolve_error_handler(500)

venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>, view_type = 500

    def resolve_error_handler(self, view_type):
>       callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <django.utils.functional.cached_property object at 0x10b78cdf0>
instance = <URLResolver 'api_yamdb.urls' (None:None) '^/'>
cls = <class 'django.urls.resolvers.URLResolver'>

    def __get__(self, instance, cls=None):
        """
        Call the function and put the return value in instance.__dict__ so that
        subsequent attribute access on the instance returns the cached value
        instead of calling cached_property.__get__().
        """
        if instance is None:
            return self
>       res = instance.__dict__[self.name] = self.func(instance)

venv/lib/python3.8/site-packages/django/utils/functional.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <URLResolver 'api_yamdb.urls' (None:None) '^/'>

    @cached_property
    def urlconf_module(self):
        # import_module is not thread safe if the module throws an exception
        # during import, and can return an empty module object in Python < 3.6
        # (see https://bugs.python.org/issue36284).
        with self._urlconf_lock:
            if isinstance(self.urlconf_name, str):
>               return import_module(self.urlconf_name)

venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api_yamdb.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api_yamdb.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10d032220>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10d032220>
module = <module 'api_yamdb.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10ccfebe0, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.py", line 1>, {'Temp...ary/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api_yamdb/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.contrib import admin
    from django.urls import path, include
    from django.views.generic import TemplateView
    
    urlpatterns = [
        path('admin/', admin.site.urls),
        path('api/v1/', include('users.urls'), name='users'),
>       path('api/', include('api.urls')),
        path(
            'redoc/',
            TemplateView.as_view(template_name='redoc.html'),
            name='redoc'
        ),
    ]

api_yamdb/api_yamdb/urls.py:8: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

arg = 'api.urls', namespace = None

    def include(arg, namespace=None):
        app_name = None
        if isinstance(arg, tuple):
            # Callable returning a namespace hint.
            try:
                urlconf_module, app_name = arg
            except ValueError:
                if namespace:
                    raise ImproperlyConfigured(
                        'Cannot override the namespace for a dynamic module that '
                        'provides a namespace.'
                    )
                raise ImproperlyConfigured(
                    'Passing a %d-tuple to include() is not supported. Pass a '
                    '2-tuple containing the list of patterns and app_name, and '
                    'provide the namespace argument to include() instead.' % len(arg)
                )
        else:
            # No namespace hint - use manually provided namespace.
            urlconf_module = arg
    
        if isinstance(urlconf_module, str):
>           urlconf_module = import_module(urlconf_module)

venv/lib/python3.8/site-packages/django/urls/conf.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                msg = ("the 'package' argument is required to perform a relative "
                       "import for {!r}")
                raise TypeError(msg.format(name))
            for character in name:
                if character != '.':
                    break
                level += 1
>       return _bootstrap._gcd_import(name[level:], package, level)

/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', package = None, level = 0

>   ???

<frozen importlib._bootstrap>:1014: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:991: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'api.urls', import_ = <function _gcd_import at 0x109e5b430>

>   ???

<frozen importlib._bootstrap>:975: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

spec = ModuleSpec(name='api.urls', loader=<_frozen_importlib_external.SourceFileLoader object at 0x10ce27a30>, origin='/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py')

>   ???

<frozen importlib._bootstrap>:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <_frozen_importlib_external.SourceFileLoader object at 0x10ce27a30>
module = <module 'api.urls' from '/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py'>

>   ???

<frozen importlib._bootstrap_external>:783: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = <built-in function exec>
args = (<code object <module> at 0x10d022660, file "/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.py", line 2>, {'DefaultRou...y/Library/Caches/com.apple.python/Users/alexey/Dev/api_yamdb/api_yamdb/api/urls.cpython-38.pyc', '__doc__': None, ...})
kwds = {}

>   ???

<frozen importlib._bootstrap>:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from rest_framework.routers import DefaultRouter
    
>   from api.views import TitleViewSet, GenreViewSet, CategoryViewSet

api_yamdb/api/urls.py:4: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    from django.db.models import Avg
    from rest_framework import viewsets, filters
    from rest_framework.pagination import PageNumberPagination
    from rest_framework.permissions import IsAuthenticated
    
    from api.permissions import (
        AdminOnlyPermission, AdminOrReadOnlyPermission, AuthorAdminModeratorPermission
    )
>   from api.serializers import (
        CategorySerializer, GenreSerializer, TitleGetSerializer,
        TitlePostSerializer,
    )

api_yamdb/api/views.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    import datetime
    from django.core.validators import MaxValueValidator
    from rest_framework.validators import UniqueTogetherValidator
    from rest_framework import serializers
    
    from reviews.models import Title, Genre, Category
    from reviews.models import Review, Comment
    
    class GenreSerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Genre
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class CategorySerializer(serializers.ModelSerializer):
    
        class Meta:
            model = Category
            fields = ('name', 'slug')
            lookup_field = 'slug'
    
    
    class TitleGetSerializer(serializers.ModelSerializer):
        category = CategorySerializer()
        genre = GenreSerializer(many=True)
        rating = serializers.IntegerField(default=0)
    
        class Meta:
            model = Title
            fields = '__all__'
            read_only_fields = ('__all__',)
    
    
    class TitlePostSerializer(serializers.ModelSerializer):
        category = serializers.SlugRelatedField(
            queryset=Category.objects.all(),
            slug_field='slug'
        )
        genre = serializers.SlugRelatedField(
            many=True,
            queryset=Genre.objects.all(),
            slug_field='slug'
        )
        year = serializers.IntegerField(
            validators=[MaxValueValidator(datetime.date.today().year)]
        )
    
        class Meta:
            model = Title
            fields = ('id', 'name', 'description', 'category',
                      'genre', 'year')
    
    
    
>   class ReviewSerializer(serializers.ModelSerializer):

api_yamdb/api/serializers.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError

During handling of the above exception, another exception occurred:

self = <tests.test_01_users.Test01UserAPI object at 0x10d08e3d0>
client = <django.test.client.Client object at 0x10d4a7880>

    @pytest.mark.django_db(transaction=True)
    def test_01_users_not_authenticated(self, client):
>       response = client.get('/api/v1/users/')

tests/test_01_users.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
venv/lib/python3.8/site-packages/django/test/client.py:535: in get
    response = super().get(path, data=data, secure=secure, **extra)
venv/lib/python3.8/site-packages/django/test/client.py:345: in get
    return self.generic('GET', path, secure=secure, **{
venv/lib/python3.8/site-packages/django/test/client.py:422: in generic
    return self.request(**r)
venv/lib/python3.8/site-packages/django/test/client.py:485: in request
    response = self.handler(environ)
venv/lib/python3.8/site-packages/django/test/client.py:140: in __call__
    response = self.get_response(request)
venv/lib/python3.8/site-packages/django/core/handlers/base.py:75: in get_response
    response = self._middleware_chain(request)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:36: in inner
    response = response_for_exception(request, exc)
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:90: in response_for_exception
    response = handle_uncaught_exception(request, get_resolver(get_urlconf()), sys.exc_info())
venv/lib/python3.8/site-packages/django/core/handlers/exception.py:128: in handle_uncaught_exception
    callback, param_dict = resolver.resolve_error_handler(500)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:601: in resolve_error_handler
    callback = getattr(self.urlconf_module, 'handler%s' % view_type, None)
venv/lib/python3.8/site-packages/django/utils/functional.py:80: in __get__
    res = instance.__dict__[self.name] = self.func(instance)
venv/lib/python3.8/site-packages/django/urls/resolvers.py:581: in urlconf_module
    return import_module(self.urlconf_name)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api_yamdb/urls.py:8: in <module>
    path('api/', include('api.urls')),
venv/lib/python3.8/site-packages/django/urls/conf.py:34: in include
    urlconf_module = import_module(urlconf_module)
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/importlib/__init__.py:127: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
<frozen importlib._bootstrap>:1014: in _gcd_import
    ???
<frozen importlib._bootstrap>:991: in _find_and_load
    ???
<frozen importlib._bootstrap>:975: in _find_and_load_unlocked
    ???
<frozen importlib._bootstrap>:671: in _load_unlocked
    ???
<frozen importlib._bootstrap_external>:783: in exec_module
    ???
<frozen importlib._bootstrap>:219: in _call_with_frames_removed
    ???
api_yamdb/api/urls.py:4: in <module>
    from api.views import TitleViewSet, GenreViewSet, CategoryViewSet
api_yamdb/api/views.py:9: in <module>
    from api.serializers import (
api_yamdb/api/serializers.py:57: in <module>
    class ReviewSerializer(serializers.ModelSerializer):
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    class ReviewSerializer(serializers.ModelSerializer):
    
        author = serializers.SlugRelatedField(
            slug_field='username', read_only=True)
        title_id = serializers.HiddenField(
>           default=serializer_field.context['request'].title_id)
E       NameError: name 'serializer_field' is not defined

api_yamdb/api/serializers.py:62: NameError
=========================== short test summary info ============================
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_nodata_signup
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_invalid_data_signup
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_valid_data_user_signup
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_valid_data_admin_create_user
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_obtain_jwt_token_invalid_data
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_registration_me_username_restricted
FAILED tests/test_00_user_registration.py::Test00UserRegistration::test_00_registration_same_email_restricted
FAILED tests/test_01_users.py::Test01UserAPI::test_01_users_not_authenticated
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! KeyboardInterrupt !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
/Library/Developer/CommandLineTools/Library/Frameworks/Python3.framework/Versions/3.8/lib/python3.8/linecache.py:55: KeyboardInterrupt
(to show a full traceback on KeyboardInterrupt use --full-trace)
============================== 8 failed in 29.29s ==============================
